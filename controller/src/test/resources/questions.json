[
  {
    "title": "Is Java \"pass-by-reference\" or \"pass-by-value\"?",
    "content": "I always thought Java uses **pass-by-reference**.\n\nHowever, I've seen [a blog post][1] that claims that Java uses **pass-by-value**.\n\nI don't think I understand the distinction they're making.\n\nWhat is the explanation?\n\n  [1]: http://javadude.com/articles/passbyvalue.htm\n",
    "votes": 97,
    "tags": [
      {
        "tag": "java"
      }
    ],
    "comments": [
      {
        "content": "We would more commonly say that a variable \"passed-by-reference\" can be mutated. The term appears in textbooks because language theorists needed a way to distinguish how you treat primitive data types (int, bool, byte) from complex and structured objects (array, streams, class) -- that is to say, those of possibly unbounded memory allocation.",
        "votes": 5
      },
      {
        "content": "I want to note that you do not have to think about this in most cases. I programmed java for many years until i learned c++. Until this point in time i had no clue what pass-by-reference and pass-by-value are. The intuitive solution always worked for me, which is why java is one of the best languages for beginners. So if you currently are worried, if your function needs a reference or a value, just pass it as it is and you will be fine.",
        "votes": 4
      },
      {
        "content": "Java pass the reference by value.",
        "votes": 54
      },
      {
        "content": "Putting it very concisely, this confusion arises because in Java all non-primitive data types are handled/accessed by references. However, passing is always be value. So for all non-primitive types reference is passed by its value. All primitive types are also passed by value.",
        "votes": 15
      }
    ],
    "answers": [
      {
        "content": "The terms \"pass-by-value\" and \"pass-by-reference\" have special, [precisely defined](https://en.wikipedia.org/w/index.php?title=Pass-by-value) meanings in computer science. These meanings differ from the intuition many people have when first hearing the terms. Much of the confusion in this discussion seems to come from this fact.\n\nThe terms \"pass-by-value\" and \"pass-by-reference\" are talking about _variables._ Pass-by-value means that the _value_ of a variable is passed to a function/method. Pass-by-reference means that a _reference_ to that variable is passed to the function. The latter gives the function a way to change the contents of the variable. \n\nBy those definitions, Java is always **pass-by-value**.  Unfortunately, when we deal with variables holding objects we are really dealing with object-handles called _references_ which are passed-by-value as well.  This terminology and semantics easily confuse many beginners.\n\nIt goes like this:\n ```java\npublic static void main(String[] args) {\n    Dog aDog = new Dog(\"Max\");\n    Dog oldDog = aDog;\n\n    // we pass the object to foo\n    foo(aDog);\n    // aDog variable is still pointing to the \"Max\" dog when foo(...) returns\n    aDog.getName().equals(\"Max\"); // true\n    aDog.getName().equals(\"Fifi\"); // false\n    aDog == oldDog; // true\n}\n\npublic static void foo(Dog d) {\n    d.getName().equals(\"Max\"); // true\n    // change d inside of foo() to point to a new Dog instance \"Fifi\"\n    d = new Dog(\"Fifi\");\n    d.getName().equals(\"Fifi\"); // true\n}\n```\nIn the example above `aDog.getName()` will still return `\"Max\"`. The value `aDog` within `main` is not changed in the function `foo` with the `Dog` `\"Fifi\"` as the object reference is passed by value. If it were passed by reference, then the `aDog.getName()` in `main` would return `\"Fifi\"` after the call to `foo`.\n\nLikewise:\n```java\npublic static void main(String[] args) {\n    Dog aDog = new Dog(\"Max\");\n    Dog oldDog = aDog;\n\n    foo(aDog);\n    // when foo(...) returns, the name of the dog has been changed to \"Fifi\"\n    aDog.getName().equals(\"Fifi\"); // true\n    // but it is still the same dog:\n    aDog == oldDog; // true\n}\n\npublic static void foo(Dog d) {\n    d.getName().equals(\"Max\"); // true\n    // this changes the name of d to be \"Fifi\"\n    d.setName(\"Fifi\");\n}\n```\nIn the above example, `Fifi` is the dog's name after call to `foo(aDog)` because the object's name was set inside of `foo(...)`. Any operations that `foo` performs on `d` are such that, for all practical purposes, they are performed on `aDog`, but it is **not** possible to change the value of the variable `aDog` itself.\n\n  [1]: http://ideone.com/oUEPbg\n\nFor more information on pass by reference and pass by value, consult the following answer: https://stackoverflow.com/a/430958/6005228. This explains more thoroughly the semantics and history behind the two and also explains why Java and many other modern languages appear to do both in certain cases.",
        "votes": 91,
        "accepted": 1,
        "comments": [
          {
            "content": "so what happens to \"Fifi\" in the 1st example? Does it cease to exist, was it never created, or does it exist in the heap but without a reference variable in the stack?",
            "votes": 7
          },
          {
            "content": "To me, saying that an object's reference is passed by value is the same as saying that the object is passed by reference. I'm a Java novice, but I presume that (in contrast) primitive data is pass by value.",
            "votes": 80
          }
        ]
      },
      {
        "content": "I just noticed you referenced [my article][1].\n\nThe Java Spec says that everything in Java is pass-by-value. There is no such thing as \"pass-by-reference\" in Java.\n\nThe key to understanding this is that something like\n```java\nDog myDog;\n```\n\nis _not_ a Dog; it's actually a _pointer_ to a Dog. The use of the term \"reference\" in Java is very misleading and is what causes most of the confusion here. What they call \"references\" act/feel more like what we'd call \"pointers\" in most other languages.\n\nWhat that means, is when you have\n```java\nDog myDog = new Dog(\"Rover\");\nfoo(myDog);\n```\nyou're essentially passing the _address_ of the created `Dog` object to the `foo` method.\n\n(I say essentially because Java pointers/references aren't direct addresses, but it's easiest to think of them that way.)\n\nSuppose the `Dog` object resides at memory address 42. This means we pass 42 to the method.\n\nif the Method were defined as\n```java\npublic void foo(Dog someDog) {\n    someDog.setName(\"Max\");     // AAA\n    someDog = new Dog(\"Fifi\");  // BBB\n    someDog.setName(\"Rowlf\");   // CCC\n}\n```\nlet's look at what's happening.\n\n   * the parameter `someDog` is set to the value 42\n   * at line \"AAA\"\n      * `someDog` is followed to the `Dog` it points to (the `Dog` object at address 42)\n      * that `Dog` (the one at address 42) is asked to change his name to Max\n   * at line \"BBB\"\n      * a new `Dog` is created. Let's say he's at address 74\n      * we assign the parameter `someDog` to 74 \n   * at line \"CCC\"\n      * someDog is followed to the `Dog` it points to (the `Dog` object at address 74)\n      * that `Dog` (the one at address 74) is asked to change his name to Rowlf\n   * then, we return\n\nNow let's think about what happens outside the method:\n\n*Did `myDog` change?*\n\nThere's the key.\n\nKeeping in mind that `myDog` is a *pointer*, and not an actual `Dog`, the answer is NO. `myDog` still has the value 42; it's still pointing to the original `Dog` (but note that because of line \"AAA\", its name is now \"Max\" - still the same Dog; `myDog`'s value has not changed.)\n\nIt's perfectly valid to *follow* an address and change what's at the end of it; that does not change the variable, however.\n\n\nJava works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, the caller will not see any changes you make to where that pointer points. (In a language with pass-by-reference semantics, the method function _can_ change the pointer and the caller will see that change.)\n\nIn C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.\n\nIf Java had pass-by-reference semantics, the `foo` method we defined above would have changed where `myDog` was pointing when it assigned `someDog` on line BBB.\n\nThink of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.\n\n## Update\nA discussion in the comments warrants some clarification...\n\nIn C, you can write\n\n```c\nvoid swap(int *x, int *y) {\n    int t = *x;\n    *x = *y;\n    *y = t;\n}\n\nint x = 1;\nint y = 2;\nswap(&x, &y);\n```\n\nThis is not a special case in C. Both languages use pass-by-value semantics. Here the call site is creating additional data structure to assist the function to access and manipulate data. \n\nThe function is being passed pointers to data, and follows those pointers to access and modify that data.\n\nA similar approach in Java, where the caller sets up assisting structure, might be:\n\n```java\nvoid swap(int[] x, int[] y) {\n    int temp = x[0];\n    x[0] = y[0];\n    y[0] = temp;\n}\n\nint[] x = {1};\nint[] y = {2};\nswap(x, y);\n```\n\n(or if you wanted both examples to demonstrate features the other language doesn't have, create a mutable IntWrapper class to use in place of the arrays)\n\nIn these cases, both C and Java are *simulating* pass-by-reference. They're still both passing values (pointers to ints or arrays), and following those pointers inside the called function to manipulate the data.\n\nPass-by-reference is all about the function *declaration/definition*, and how it handles its parameters. Reference semantics apply to *every* call to that function, and the call site only needs to pass variables, no additional data structure.\n\nThese simulations require the call site and the function to cooperate. No doubt it's useful, but it's still pass-by-value.\n\n  [1]: http://javadude.com/articles/passbyvalue.htm",
        "votes": 89,
        "accepted": 0,
        "comments": []
      },
      {
        "content": "Java is always pass by value, with no exceptions, **ever**.\n\nSo how is it that anyone can be at all confused by this, and believe that Java is pass by reference, or think they have an example of Java acting as pass by reference? The key point is that Java **never** provides direct access to the values of *objects themselves*, in *any* circumstances. The only access to objects is through a _reference_ to that object. Because Java objects are *always* accessed through a reference, rather than directly, it is common to talk about fields and variables *and method arguments* as being *objects*, when pedantically they are only *references to objects*. **The confusion stems from this (strictly speaking, incorrect) change in nomenclature.**\n\nSo, when calling a method\n\n* For primitive arguments (`int`, `long`, etc.), the pass by value is *the actual value* of the primitive (for example, 3).\n* For objects, the pass by value is the value of *the reference to the object*.\n\nSo if you have `doSomething(foo)` and `public void doSomething(Foo foo) { .. }` the two Foos have copied *references* that point to the same objects.\n\nNaturally, passing by value a reference to an object looks very much like (and is indistinguishable in practice from) passing an object by reference.",
        "votes": 30,
        "accepted": 0,
        "comments": [
          {
            "content": "Java always passes arguments by value, but what you are passing by value is a reference to an object, not a copy of the object. Simple eh?",
            "votes": 57
          }
        ]
      },
      {
        "content": "Java passes references by value.\n\nSo you can't change the reference that gets passed in.",
        "votes": 30,
        "accepted": 0,
        "comments": [
          {
            "content": "What a beautiful and concised explaination",
            "votes": 5
          }
        ]
      }
    ]
  },
  {
    "title": "Why is subtracting these two times (in 1927) giving a strange result?",
    "content": "If I run the following program, which parses two date strings referencing times 1 second apart and compares them:\n```java\npublic static void main(String[] args) throws ParseException {\n\tSimpleDateFormat sf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");  \n\tString str3 = \"1927-12-31 23:54:07\";  \n\tString str4 = \"1927-12-31 23:54:08\";  \n\tDate sDt3 = sf.parse(str3);  \n\tDate sDt4 = sf.parse(str4);  \n\tlong ld3 = sDt3.getTime() /1000;  \n\tlong ld4 = sDt4.getTime() /1000;\n\tSystem.out.println(ld4-ld3);\n}\n```\n**The output is:**\n```java\n353\n```\nWhy is `ld4-ld3`, not `1` (as I would expect from the one-second difference in the times), but `353`?\n\nIf I change the dates to times 1 second later:\n```java\nString str3 = \"1927-12-31 23:54:08\";  \nString str4 = \"1927-12-31 23:54:09\";  \n```\nThen `ld4-ld3` will be `1`.\n\n----------\n\n**Java version:**\n```java\njava version \"1.6.0_22\"\nJava(TM) SE Runtime Environment (build 1.6.0_22-b04)\nDynamic Code Evolution Client VM (build 0.2-b02-internal, 19.0-b04-internal, mixed mode)\n```\n```java\nTimezone(`TimeZone.getDefault()`):\n\nsun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",\noffset=28800000,dstSavings=0,\nuseDaylight=false,\ntransitions=19,\nlastRule=null]\n\nLocale(Locale.getDefault()): zh_CN\n```",
    "votes": 98,
    "tags": [
      {
        "tag": "java"
      }
    ],
    "comments": [
      {
        "content": "The real answer is to always, always use seconds since an epoch for logging, like the Unix epoch, with 64 bit integer representation (signed, if you want to allow stamps before the epoch). Any real-world time system has some non-linear, non-monotonic behaviour like leap hours or daylight savings.",
        "votes": 55
      }
    ],
    "answers": [
      {
        "content": "It's a time zone change on December 31st in Shanghai.\n\nSee [this page][1] for details of 1927 in Shanghai. Basically at midnight at the end of 1927, the clocks went back 5 minutes and 52 seconds. So \"1927-12-31 23:54:08\" actually happened twice, and it looks like Java is parsing it as the *later* possible instant for that local date/time - hence the difference.\n\nJust another episode in the often weird and wonderful world of time zones.\n\n**EDIT:** Stop press! History changes...\n\nThe original question would no longer demonstrate quite the same behaviour, if rebuilt with version 2013a of [TZDB][2]. In 2013a, the result would be 358 seconds, with a transition time of 23:54:03 instead of 23:54:08.\n\nI only noticed this because I'm collecting questions like this in Noda Time, in the form of [unit tests][3]... The test has now been changed, but it just goes to show - not even historical data is safe.\n\n**EDIT:** History has changed again...\n\nIn TZDB 2014f, the time of the change has moved to 1900-12-31, and it's now a mere 343 second change (so the time between `t` and `t+1` is 344 seconds, if you see what I mean).\n\n**EDIT:** To answer a question around a transition at 1900... it looks like the Java timezone implementation treats *all* time zones as simply being in their standard time for any instant before the start of 1900 UTC:\n```java\nimport java.util.TimeZone;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        long startOf1900Utc = -2208988800000L;\n        for (String id : TimeZone.getAvailableIDs()) {\n            TimeZone zone = TimeZone.getTimeZone(id);\n            if (zone.getRawOffset() != zone.getOffset(startOf1900Utc - 1)) {\n                System.out.println(id);\n            }\n        }\n    }\n}\n```\nThe code above produces no output on my Windows machine. So any time zone which has any offset other than its standard one at the start of 1900 will count that as a transition. TZDB itself has some data going back earlier than that, and doesn't rely on any idea of a \"fixed\" standard time (which is what `getRawOffset` assumes to be a valid concept) so other libraries needn't introduce this artificial transition.\n\n\n  [1]: http://www.timeanddate.com/worldclock/clockchange.html?n=237&year=1927\n  [2]: https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68\n  [3]: https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68\n",
        "votes": 77,
        "accepted": 1,
        "comments": []
      },
      {
        "content": "You've encountered a [local time discontinuity][1]:\n\n> When local standard time was about to reach Sunday, 1. January 1928,\n> 00:00:00 clocks were turned backward 0:05:52 hours to Saturday, 31.\n> December 1927, 23:54:08 local standard time instead\n\nThis is not particularly strange and has happened pretty much everywhere at one time or another as timezones were switched or changed due to political or administrative actions.\n\n\n  [1]: http://timeanddate.com/worldclock/clockchange.html?n=237&year=1927",
        "votes": 13,
        "accepted": 0,
        "comments": [
          {
            "content": "It happens twice a year anywhere that observes DST.",
            "votes": 11
          },
          {
            "content": "This one is not DST, I think. It's only 10 minutes back, and only once. At the same time, DST related changes can happen twice a year... or 4 times a year (due to Ramadan). or even once a year in some setups. No rule there :)",
            "votes": 5
          }
        ]
      },
      {
        "content": "The moral of this strangeness is:\n\n- Use dates and times in UTC wherever possible.\n- If you can not display a date or time in UTC, always indicate the time-zone.\n- If you can not require an input date/time in UTC, require an explicitly indicated time-zone.",
        "votes": 13,
        "accepted": 0,
        "comments": [
          {
            "content": "None of these points would affect this result - it falls squarely under the third bullet point - and moreover, this is a time several decades before UTC was even defined, and thus can not really meaningfully be expressed in UTC.",
            "votes": 3
          }
        ]
      }
    ]
  },
  {
    "title": "How do I read / convert an InputStream into a String in Java?",
    "content": "If you have a `java.io.InputStream` object, how should you process that object and produce a `String`?\n\n---\nSuppose I have an `InputStream` that contains text data, and I want to convert it to a `String`, so for example I can write that to a log file.\n\nWhat is the easiest way to take the `InputStream` and convert it to a `String`?\n```java\npublic String convertStreamToString(InputStream is) {\n// ???\n}\n```",
    "votes": 74,
    "tags": [
      {
        "tag": "java"
      }
    ],
    "comments": [
      {
        "content": "Most of these answers were written pre-Java 9, but now you can get a byte array from the InputStream using .readAllBytes. So, simply \"new String(inputStream.readAllBytes())\" works using String's byte[] constructor.",
        "votes": 3
      }
    ],
    "answers": [
      {
        "content": "Here's a way using only the standard Java library (note that the stream is not closed, your mileage may vary).\n```java\nstatic String convertStreamToString(java.io.InputStream is) {\n    java.util.Scanner s = new java.util.Scanner(is).useDelimiter(\"\\\\A\");\n    return s.hasNext() ? s.next() : \"\";\n}\n```\nI learned this trick from [\"Stupid Scanner tricks\"][1] article. The reason it works is because [Scanner][2] iterates over tokens in the stream, and in this case we separate tokens using \"beginning of the input boundary\" (\\A), thus giving us only one token for the entire contents of the stream.\n\n**Note, if you need to be specific about the input stream's encoding, you can provide the second argument to `Scanner` constructor that indicates what character set to use (e.g. \"UTF-8\").**\n\nHat tip goes also to [Jacob][3], who once pointed me to the said article.\n\n  [1]: https://community.oracle.com/blogs/pat/2004/10/23/stupid-scanner-tricks\n  [2]: http://download.oracle.com/javase/8/docs/api/java/util/Scanner.html\n  [3]: https://stackoverflow.com/users/68127/jacob-gabrielson\n  [4]: https://stackoverflow.com/users/101272/patrick\n\n\n",
        "votes": 15,
        "accepted": 1,
        "comments": [
          {
            "content": "Shouldn't we close the scanner before returning the value?",
            "votes": 1
          }
        ]
      },
      {
        "content": "Apache Commons allows:\n```java\nString myString = IOUtils.toString(myInputStream, \"UTF-8\");\n```\nOf course, you could choose other character encodings besides UTF-8.\n\nAlso see: ([documentation][1])\n\n  [1]: http://commons.apache.org/proper/commons-io/javadocs/api-2.4/org/apache/commons/io/IOUtils.html#toString%28java.io.InputStream,%20java.lang.String\n\n",
        "votes": 8,
        "accepted": 0,
        "comments": []
      },
      {
        "content": "Taking into account file one should first get a `java.io.Reader` instance. This can then be read and added to a `StringBuilder` (we don't need `StringBuffer` if we are not accessing it in multiple threads, and `StringBuilder` is faster). The trick here is that we work in blocks, and as such don't need other buffering streams. The block size is parameterized for run-time performance optimization.\n```java\npublic static String slurp(final InputStream is, final int bufferSize) {\n    final char[] buffer = new char[bufferSize];\n    final StringBuilder out = new StringBuilder();\n    try (Reader in = new InputStreamReader(is, \"UTF-8\")) {\n        for (;;) {\n            int rsz = in.read(buffer, 0, buffer.length);\n            if (rsz < 0)\n                break;\n            out.append(buffer, 0, rsz);\n        }\n    }\n    catch (UnsupportedEncodingException ex) {\n        /* ... */\n    }\n    catch (IOException ex) {\n        /* ... */\n    }\n    return out.toString();\n}\n```",
        "votes": 11,
        "accepted": 0,
        "comments": []
      },
      {
        "content": "For completeness here is **Java 9** solution:\n```java\npublic static String toString(InputStream input) throws IOException {\n    return new String(input.readAllBytes(), StandardCharsets.UTF_8);\n}\n```\nThis uses the [`readAllBytes`](https://docs.oracle.com/javase/9/docs/api/java/io/InputStream.html#readAllBytes--) method which was added to Java 9.",
        "votes": 5,
        "accepted": 0,
        "comments": []
      }
    ]
  },
  {
    "title": "Create ArrayList from array",
    "content": "Given an array of type `Element[]`:\n```java\nElement[] array = {new Element(1), new Element(2), new Element(3)};\n```\nHow do I convert this array into an object of type [`ArrayList<Element>`][1]?\n```java\nArrayList<Element> arrayList = ???;\n```\n\n  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html",
    "votes": 55,
    "tags": [
      {
        "tag": "java"
      }
    ],
    "comments": [
    ],
    "answers": [
      {
        "content": "```java\nnew ArrayList<>(Arrays.asList(array));\n```",
        "votes": 57,
        "accepted": 1,
        "comments": [
          {
            "content": "Yep. And in the (most common) case where you just want a list, the new ArrayList call is unecessary as well.",
            "votes": 44
          },
          {
            "content": "Arrays.asList() is a horrible function, and you should never just use its return value as is. It breaks the List template, so always use it in the form indicated here, even if it does seem redundant. Good answer.",
            "votes": 26
          },
          {
            "content": "Please study the javadoc for java.util.List. The contract for add allows them to throw an UnsupportedOperationException. Admittedly, from an object-oriented perspective it is not very nice that many times you have to know the concrete implementation in order to use a collection - this was a pragmatic design choice in order to keep the framework simple.",
            "votes": 36
          }
        ]
      },
      {
        "content": "Given:\n```java\nElement[] array = new Element[] { new Element(1), new Element(2), new Element(3) };\n```\nThe simplest answer is to do:\n```java\nList<Element> list = Arrays.asList(array);\n```\nThis will work fine.  But some caveats:\n\n 1. The list returned from asList has **fixed size**.  So, if you want to be able to add or remove elements from the returned list in your code, you'll need to wrap it in a new `ArrayList`.  Otherwise you'll get an `UnsupportedOperationException`.\n 2. The list returned from `asList()` is backed by the original array.  If you modify the original array, the list will be modified as well.  This may be surprising. \n",
        "votes": 34,
        "accepted": 0,
        "comments": []
      },
      {
        "content": "# If You Can, Use Guava\n\nIt's worth pointing out the Guava way, which greatly simplifies these shenanigans:\n\n## Usage\n\n### For an Immutable List\n\nUse the [`ImmutableList`][1] class and its [`of()`][2] and [`copyOf()`][3] factory methods <sup>(elements can't be null)</sup>:\n```java\nList<String> il = ImmutableList.of(\"string\", \"elements\");  // from varargs\nList<String> il = ImmutableList.copyOf(aStringArray);      // from array\n```\n### For A Mutable List\n\nUse the [`Lists`][4] class and its [`newArrayList()`][5] factory methods:\n```java\nList<String> l1 = Lists.newArrayList(anotherListOrCollection);    // from collection\nList<String> l2 = Lists.newArrayList(aStringArray);               // from array\nList<String> l3 = Lists.newArrayList(\"or\", \"string\", \"elements\"); // from varargs\n```\nPlease also note the similar methods for other data structures in other classes, for instance in [`Sets`][6].\n\n## [Why Guava?][7]\n\nThe main attraction could be to reduce the clutter due to generics for type-safety, as the use of the Guava [factory methods][8] allow the types to be inferred most of the time. However, this argument holds less water since Java 7 arrived with the new diamond operator.\n\nBut it's not the only reason (and Java 7 isn't everywhere yet): the shorthand syntax is also very handy, and the methods initializers, as seen above, allow to write more expressive code. You do in one Guava call what takes 2 with the current Java Collections.\n\n-----\n\n# If You Can't...\n\n## For an Immutable List\n\nUse the JDK's [`Arrays`][9] class and its [`asList()`][10] factory method, wrapped with a [`Collections.unmodifiableList()`][11]:\n```java\nList<String> l1 = Collections.unmodifiableList(Arrays.asList(anArrayOfElements));\nList<String> l2 = Collections.unmodifiableList(Arrays.asList(\"element1\", \"element2\"));\n```\nNote that the returned type for `asList()` is a `List` using a concrete `ArrayList` implementation, but **it is NOT** `java.util.ArrayList`. It's an inner type, which emulates an `ArrayList` but actually directly references the passed array and makes it \"write through\" (modifications are reflected in the array).\n\nIt forbids modifications through some of the `List` API's methods by way of simply extending an `AbstractList` (so, adding or removing elements is unsupported), however it allows calls to `set()` to override elements. Thus this list isn't truly immutable and a call to `asList()` should be wrapped with `Collections.unmodifiableList()`.\n\nSee the next step if you need a mutable list.\n\n## For a Mutable List\n\nSame as above, but wrapped with an actual `java.util.ArrayList`:\n```java\nList<String> l1  = new ArrayList<String>(Arrays.asList(array));    // Java 1.5 to 1.6\nList<String> l1b = new ArrayList<>(Arrays.asList(array));          // Java 1.7+\nList<String> l2  = new ArrayList<String>(Arrays.asList(\"a\", \"b\")); // Java 1.5 to 1.6\nList<String> l2b = new ArrayList<>(Arrays.asList(\"a\", \"b\"));       // Java 1.7+\n```\n----\n\n# For Educational Purposes: The Good ol' Manual Way\n```java\n// for Java 1.5+\nstatic <T> List<T> arrayToList(final T[] array) {\nfinal List<T> l = new ArrayList<T>(array.length);\n\n  for (final T s : array) {\n    l.add(s);\n  }\n  return (l);\n}\n\n// for Java < 1.5 (no generics, no compile-time type-safety, boo!)\nstatic List arrayToList(final Object[] array) {\n  final List l = new ArrayList(array.length);\n   for (int i = 0; i < array.length; i++) {\n    l.add(array[i]);\n  }\n  return (l);\n}\n```\n\n   [1]: https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java\n  [2]: https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L108\n  [3]: https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L235\n  [4]: https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java\n  [5]: https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L84\n  [6]: https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Sets.java\n  [7]: https://github.com/google/guava/wiki\n  [8]: https://github.com/google/guava/wiki/CollectionUtilitiesExplained#static-constructors\n  [9]: https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Arrays.html\n  [10]: https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Arrays.html#asList(T...)\n  [11]: https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Collections.html#unmodifiableList(java.util.List)",
        "votes": 41,
        "accepted": 0,
        "comments": [
          {
            "content": "But note that the List returned by Arrays.asList is mutable in that you can still set elements - it just isn't resizable. For immutable lists without Guava you might mention Collections.unmodifiableList",
            "votes": 22
          }
        ]
      }
    ]
  }
]